const fs = require('fs');
const path = require('path');
const express = require('express');
const { CloudAdapter, ConfigurationBotFrameworkAuthentication } = require('botbuilder');
const GLJTeamsBot = require('./teamsBot');
const redisClient = require('./redisClient');
const logger = require('./logger');
const appInsights = require("applicationinsights");

const app = express();
const PORT = process.env.PORT || 3978;

// Application Insights åˆæœŸåŒ–
if (process.env.APPINSIGHTS_INSTRUMENTATIONKEY) {
    appInsights.setup(process.env.APPINSIGHTS_INSTRUMENTATIONKEY)
        .setAutoDependencyCorrelation(true)
        .setAutoCollectRequests(true)
        .setAutoCollectPerformance(true)
        .setAutoCollectExceptions(true)
        .start();
    logger.info('âœ… Application Insights åˆæœŸåŒ–å®Œäº†');
} else {
    logger.warn('âš ï¸ APPINSIGHTS_INSTRUMENTATIONKEY ãŒæœªè¨­å®šã®ãŸã‚ã€Application Insights ã¯ç„¡åŠ¹ã§ã™');
}

// Key Vault ã‹ã‚‰èªè¨¼æƒ…å ±ã‚’å–å¾—ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
async function initializeBotCredentials() {
    if (process.env.USE_KEYVAULT === 'true') {
        const { DefaultAzureCredential } = require('@azure/identity');
        const { SecretClient } = require('@azure/keyvault-secrets');
        const credential = new DefaultAzureCredential();
        const keyVaultUrl = `https://${process.env.KEY_VAULT_NAME}.vault.azure.net`;
        const secretClient = new SecretClient(keyVaultUrl, credential);

        const secretKeys = [
            'MicrosoftAppId',
            'MicrosoftAppType',
            'MicrosoftAppTenantId',
            'MicrosoftAppCertificateThumbprint',
            'MicrosoftAppCertificateFile'
        ];

        for (const key of secretKeys) {
            try {
                const secret = await secretClient.getSecret(key);
                process.env[key] = secret.value;
                logger.info(`ğŸ” KeyVaultã‹ã‚‰${key}ã‚’å–å¾—`);
            } catch (err) {
                logger.error(`âŒ KeyVaultã‹ã‚‰${key}ã®å–å¾—ã«å¤±æ•—: ${err.message}`);
                throw err;
            }
        }
    } else {
        logger.info('ğŸ”§ Key Vaultã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã€ç’°å¢ƒå¤‰æ•°ã‹ã‚‰èªè¨¼æƒ…å ±ã‚’ä½¿ç”¨ã—ã¾ã™');
    }

    // è¨¼æ˜æ›¸ãƒ­ã‚°å‡ºåŠ›ï¼ˆç’°å¢ƒå¤‰æ•°ã«ã‚ã‚‹å ´åˆï¼‰
    if (process.env.MicrosoftAppCertificateFile) {
        const certPath = process.env.MicrosoftAppCertificateFile;
        const certThumbprint = process.env.MicrosoftAppCertificateThumbprint;
        logger.info(`ğŸ“ è¨¼æ˜æ›¸ãƒ‘ã‚¹: ${certPath}`);
        logger.info(`ğŸ”‘ æ‹‡å°: ${certThumbprint}`);
        logger.info(`ğŸ“„ è¨¼æ˜æ›¸ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª: ${fs.existsSync(certPath)}`);
    }
}

// ãƒ¡ã‚¤ãƒ³å‡¦ç†
(async () => {
    try {
        await initializeBotCredentials();

        const botFrameworkAuthentication = new ConfigurationBotFrameworkAuthentication(process.env);
        const adapter = new CloudAdapter(botFrameworkAuthentication);

        adapter.onTurnError = async (context, error) => {
            logger.error(`âŒ [onTurnError] ${error}`);
            await context.sendActivity('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãã—ã¦ã‹ã‚‰ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
        };

        const bot = new GLJTeamsBot(redisClient);

        // å¥åº·ãƒã‚§ãƒƒã‚¯
        app.get('/healthz', (req, res) => {
            const healthStatus = {
                status: 'ok',
                timestamp: new Date().toISOString(),
                db: redisClient.connected ? 'connected' : 'disconnected',
                memory: `${(process.memoryUsage().rss / 1024 / 1024).toFixed(2)} MB`,
                uptime: `${process.uptime().toFixed(2)} seconds`,
                nodeVersion: process.version
            };
            res.status(200).json(healthStatus);
        });

        app.get('/', (req, res) => {
            res.status(200).json({
                status: 'running',
                app: 'GLJ Teams Bot',
                version: process.env.npm_package_version || 'unknown'
            });
        });

        app.post('/api/messages', express.json(), async (req, res) => {
            await adapter.process(req, res, async (context) => {
                await bot.run(context);
            });
        });

        // ã‚¨ãƒ©ãƒ¼å‡¦ç†
        process.on('uncaughtException', (err) => {
            logger.error(`âŒ uncaughtException: ${err.stack}`);
            if (appInsights.defaultClient) {
                appInsights.defaultClient.trackException({ exception: err });
            }
        });

        process.on('unhandledRejection', (reason) => {
            logger.error(`âŒ unhandledRejection: ${reason}`);
            if (appInsights.defaultClient) {
                appInsights.defaultClient.trackException({ exception: new Error(reason) });
            }
        });

        // ã‚µãƒ¼ãƒãƒ¼èµ·å‹•
        const server = app.listen(PORT, '0.0.0.0', () => {
            logger.info(`ğŸŸ¢ ã‚µãƒ¼ãƒãƒ¼èµ·å‹•ä¸­ï¼šhttp://0.0.0.0:${PORT}`);
        });

        server.keepAliveTimeout = 60000;
        server.headersTimeout = 65000;

        process.on('SIGTERM', () => {
            logger.info('ğŸ›‘ SIGTERM ã‚’å—ä¿¡ã€‚ã‚°ãƒ¬ãƒ¼ã‚¹ãƒ•ãƒ«ã‚·ãƒ£ãƒƒãƒˆãƒ€ã‚¦ãƒ³ã‚’é–‹å§‹...');
            server.close(() => {
                logger.info('ğŸ›‘ ã‚µãƒ¼ãƒãƒ¼ãŒæ­£å¸¸ã«åœæ­¢ã—ã¾ã—ãŸ');
                process.exit(0);
            });
        });

    } catch (error) {
        logger.error(`âŒ Botèµ·å‹•æ™‚ã®è‡´å‘½çš„ã‚¨ãƒ©ãƒ¼: ${error.message}`);
        process.exit(1);
    }
})();

